{
    "docs": [
        {
            "location": "/",
            "text": "Virtual environment manager for Weka, inspired by the extremely useful virtual \nenvironments that Python supports.\n\n\nweka-virtualenv\n can be used for launching the GUI or arbitrary Weka classes.\n\n\nSince \nweka-virtualenv\n uses options starting with double-dashes (\n--\n), clashes with \nWeka options are avoided. Any option that wasn't consumed by \nweka-virtualenv\n \nwill get further processed by the command. E.g., when launching the Explorer\nusing the \nexplorer\n command, a dataset can be supplied to load immediately, \nor, when executing a classifier using the \nrun\n command, any additional option \nwill get passed to the Weka class.\n\n\nYou can use the tool either through the command-line or through its user \ninterface. Some basic scripting support is avaiilable through the \nscript\n\ncommand-line command (see \nScripting\n section).\n\n\nNote\n\nYou still need to install Weka yourself, \nweka-virtualenv\n only helps you\nseparating your various Weka installations. It is mainly aimed at separating\npackages.\n\n\nHow it works\n\n\nThe tool simply uses existing Weka functionality, namely the \nWEKA_HOME\n\nenvironment variable, for separating the various environments. \nWhen launching a class or GUI tool, it launches a new Java process with the\n\nWEKA_HOME\n environment variable pointing to the current environment's\n\nwekafiles\n directory. \n\n\nIf an environment has no Java or heap size configure (\n<default>\n), then it \njust uses the system's default settings for launching the new process.\n\n\nUser interface\n\n\nYou can start the GUI with the following script from the \nbin\n directory:\n\n\n\n\nLinux/Mac: \nwenvgui.sh\n\n\nWindows: \nwenvgui.bat\n\n\n\n\n\n\nArff Command Selector\n\n\nThis little tool lets you choose environment and application (Explorer or Arff \nViewer) to launch, using the provided dataset filenames (e.g., \nOpen with\n from \nthe right-click mouse context menu):\n\n\n\n\nLinux/Mac: \nwenvarff.sh\n\n\nWindows: \nwenvarff.bat\n\n\n\n\n\n\nVideos\n\n\nYou can find videos for the tool in the following YouTube playlist:\n\n\nweka-virtualenv playlist\n\n\nWindows users\n just have to substitute the \nwenv.sh\n and \nwenvgui.sh\n scripts\nwith \nwenv.bat\n and \nwenvgui.bat\n. For adding the tool's \nbin\n directory to\nyour \nPATH\n environment variable (to make it available from the command prompt),\nfollow \nthese instructions\n.",
            "title": "Home"
        },
        {
            "location": "/#how-it-works",
            "text": "The tool simply uses existing Weka functionality, namely the  WEKA_HOME \nenvironment variable, for separating the various environments. \nWhen launching a class or GUI tool, it launches a new Java process with the WEKA_HOME  environment variable pointing to the current environment's wekafiles  directory.   If an environment has no Java or heap size configure ( <default> ), then it \njust uses the system's default settings for launching the new process.",
            "title": "How it works"
        },
        {
            "location": "/#user-interface",
            "text": "You can start the GUI with the following script from the  bin  directory:   Linux/Mac:  wenvgui.sh  Windows:  wenvgui.bat",
            "title": "User interface"
        },
        {
            "location": "/#arff-command-selector",
            "text": "This little tool lets you choose environment and application (Explorer or Arff \nViewer) to launch, using the provided dataset filenames (e.g.,  Open with  from \nthe right-click mouse context menu):   Linux/Mac:  wenvarff.sh  Windows:  wenvarff.bat",
            "title": "Arff Command Selector"
        },
        {
            "location": "/#videos",
            "text": "You can find videos for the tool in the following YouTube playlist:  weka-virtualenv playlist  Windows users  just have to substitute the  wenv.sh  and  wenvgui.sh  scripts\nwith  wenv.bat  and  wenvgui.bat . For adding the tool's  bin  directory to\nyour  PATH  environment variable (to make it available from the command prompt),\nfollow  these instructions .",
            "title": "Videos"
        },
        {
            "location": "/commands/",
            "text": "Available commands:\n\nalias-add <options> <args>\n    Adds an alias definition, i.e., shortcut for command and options.\n    All options not consumed by this command will get used as options for the alias.\n    No checks are being performed on the correctness.\n\nalias-del <options>\n    Removes an alias definition.\n\nalias-exec <options> <args>\n    Executes an alias definition, i.e., shortcut for command and options.\n    All options not consumed by this command will get used as additional options for the alias.\n    No checks are being performed on the correctness.\n\nalias-list <options>\n    Lists aliases and their associated options.\n    Listing can be for global aliases, per environment, or for all.\n\narffviewer <env> <args> | output filter(s)\n    Launches the Weka Arff viewer.\n    You can supply dataset filenames to load immediately in the viewer.\n\nclone <options>\n    Clones an existing environment.\n    Allows adjusting of environment parameters.\n\ncreate <options>\n    Creates a new environment.\n    Can be initialized with the content of an existing 'wekafiles' directory.\n\ndelete <options>\n    Deletes an existing environment.\n\necho <options> | output filter(s)\n    Outputs the specified message.\n\nexperimenter <env> <args> | output filter(s)\n    Launches the Weka Experimenter.\n\nexplorer <env> <args> | output filter(s)\n    Launches the Weka Explorer.\n    You can supply a dataset filename to load immediately in the Explorer.\n\nfilter_help <options>\n    Prints help on the available output filters.\n\nguichooser <env> | output filter(s)\n    Launches the Weka GUIChooser.\n\nhelp\n    Outputs help information.\n\ninstall <options>\n    Downloads and installs a specific Weka version.\n    NB: The downloaded zip file contains a sub-directory with the version of Weka.\n\nknowledgeflow <env> <args> | output filter(s)\n    Launches the Weka KnowledgeFlow.\n    You can supply a flow file to load immediately.\n\nlist_cmds\n    Lists all available commands.\n\nlist_envs <options>\n    Lists all available environments.\n\npkgmgr <env> <args> | output filter(s)\n    Executes the commandline package manager.\n    You can supply additional options to the package manager, like '-list-packages'.\n\npkgmgr-gui <env> | output filter(s)\n    Launches the package manager user interface.\n\nreset <options>\n    Deletes an existing environment, i.e., deletes the \"wekafiles\" sub-directory.\n\nrun <env> <options> <args> | output filter(s)\n    Executes an arbitrary class with the unconsumed command-line options.\n\nscript <options>\n    Executes the commands in the specified script file.\n    Empty lines and lines starting with # get skipped.\n\nscript_help <options>\n    Prints help on the available script commands.\n\nsqlviewer <env> | output filter(s)\n    Launches the Weka SQL Viewer.\n\nstatus\n    Outputs some status information.\n\nupdate <env> <options>\n    Allows adjusting of parameters of an existing environment.\n\nworkbench <env> | output filter(s)\n    Launches the Weka Workbench.\n\n\nNotes:\n<env>\n    the name of the environment to use for the command.\n<options>\n    the command supports additional options,\n    you can use --help as argument to see further details.\n<args>\n    the command passes on all unconsumed options to the \n    underlying process\n| output filter(s)\n    the command generates output which can filtered, \n    these filters can be chained, one '|' per filter",
            "title": "Commands"
        },
        {
            "location": "/extend/",
            "text": "Automatic class discovery\n\n\nThanks to the automatic class discovery (provided by \n\njclasslocator\n), you don't have\nto register anything, you only have to place the command in the same package\nas the abstract superclass or interface.\n\n\nCommand-line\n\n\nIt is quite easy to add new commands to the tool:\n\n\n\n\ncreate a class derived from \ncom.github.fracpete.wekavirtualenv.command.AbstractCommand\n\n\nplace the class in package \ncom.github.fracpete.wekavirtualenv.command\n\n\n\n\nDataset filenames\n\n\nIf your command should handle additional arguments as dataset filenames, then\nimplement the indicator interface \ncom.github.fracpete.wekavirtualenv.command.DatasetHandler\n.\n\n\nThis interface is used by the \ncom.github.fracpete.wekavirtualenv.gui.ArffCommandSelector\n\ntool, listing all the tools in the dropdown box that implement this interface.\nBy default, these are by default only the \nExplorer\n and \nArffViewer\n.  \n\n\nHandling arguments\n\n\nThe \nDelete\n command just takes a single option, which is the name of the\nenvironment to delete. In order for the parsing to work, you have to define\na \nArgumentParser\n object in the \ngetParser\n method and then access the\nparsed options in the \ndoExecute\n method, using the \nNamespace\n object.\n\n\nHere is the \nDelete\n command's code:\n\n\npublic class Delete extends AbstractCommand {\n\n  public String getName() {\n    return \"delete\";\n  }\n\n  public String getHelp() {\n    return \"Deletes an existing environment.\";\n  }\n\n  public ArgumentParser getParser() {\n    ArgumentParser result = new ArgumentParser(getName());\n    result.addOption(\"--name\")\n      .dest(\"name\")\n      .help(\"the name of the environment to delete\")\n      .required(true);\n    return result;\n  }\n\n  protected boolean doExecute(Namespace ns, String[] options) {\n    String msg = Environments.delete(ns.getString(\"name\"));\n    if (msg != null)\n      addError(\"Failed to delete environment '\" + ns.getString(\"name\") + \"':\\n\" + msg);\n    else\n      System.out.println(\"Environment successfully deleted: \" + ns.getString(\"name\"));\n    return (msg == null);\n  }\n}\n\n\n\n\nFor more information on the parsing, check out the \n\nsimple-argparse4j\n\nproject page.\n\n\nExecuting class with main method\n\n\nThe \nAbstractLaunchCommand\n class makes it easier to execute a class that\nhas a \nmain\n method.\n\n\nThe class for launching the Weka Explorer is quite simple:\n\n\npublic class Explorer extends AbstractLaunchCommand implements DatasetHandler {\n\n  public String getName() {\n    return \"explorer\";\n  }\n\n  public String getHelp() {\n    return \"Launches the Weka Explorer.\\n\"\n      + \"You can supply a dataset filename to load immediately in the Explorer.\";\n  }\n\n  public boolean supportsAdditionalArguments() {\n    return true;\n  }\n\n  protected boolean doExecute(Namespace ns, String[] options) {\n    return launch(build(\"weka.gui.explorer.Explorer\", options));\n  }\n}\n\n\n\n\n\nIn the \ndoExecute\n method, the \nbuild\n method takes the class name and any\noptions that the class should process. In the Explorer's case an optional \ndataset to load.\n\n\nScript command\n\n\nIf you want to add a script command, you just have to derive it from the\n\ncom.github.fracpete.wekavirtualenv.command.script.AbstractScriptCommand\n\nsuper class and place it in the \ncom.github.fracpete.wekavirtualenv.command.script\n\npackage.\n\n\nHere is the code for the \nDirName\n command:\n\n\npublic class DirName extends AbstractScriptCommand {\n\n  public String getName() {\n    return \"dir_name\";\n  }\n\n  public String getHelp() {\n    return \"Extracts the path from the specified file variable.\";\n  }\n\n  public ArgumentParser getParser() {\n    ArgumentParser result = new ArgumentParser(getName());\n    result.addOption(\"--file\")\n      .dest(\"file\")\n      .help(\"the full path to extract the path from.\")\n      .required(true);\n    result.addOption(\"--dest\")\n      .dest(\"dest\")\n      .help(\"the name of the variable to store the result in.\")\n      .required(true);\n    return result;\n  }\n\n  protected boolean evalCommand(Namespace ns, String[] options) {\n    File file = new File(ns.getString(\"file\"));\n    getContext().getVariables().set(ns.getString(\"dest\"), file.getParentFile().getAbsolutePath());\n    return true;\n  }\n}\n\n\n\n\nFilter\n\n\nIf you want to add a custom output filter (like grep or tee), then you only\nhave to implement the \ncom.github.fracpete.wekavirtualenv.command.filter.Filter\n\ninterface (or use the abstract superclass \nAbstractFilter\n for convenience)\nand place it in the \ncom.github.fracpete.wekavirtualenv.command.filter\n package.\n\n\nHere is the code for the \nGrep\n filter:\n\n\npublic class Grep\n  extends AbstractFilter {\n\n  /** the pattern for matching. */\n  protected Pattern m_RegExp;\n\n  protected boolean m_Invert;\n\n  public String getName() {\n    return \"grep\";\n  }\n\n  @Override\n  public String getHelp() {\n    return \"For capturing strings that match a regular expression.\";\n  }\n\n  public ArgumentParser getParser() {\n    ArgumentParser result = super.getParser();\n    result.addOption(\"--regexp\")\n      .dest(\"regexp\")\n      .help(\"the regular expression that the output must match to be kept.\")\n      .required(true);\n    result.addOption(\"--invert\")\n      .dest(\"invert\")\n      .help(\"whether to invert the matching sense.\")\n      .argument(false);\n    return result;\n  }\n\n  public boolean initialize(Namespace ns) {\n    boolean result = super.initialize(ns);\n    if (result) {\n      try {\n    m_RegExp = Pattern.compile(ns.getString(\"regexp\"));\n      }\n      catch (Exception e) {\n        addError(\"Invalid regular expression: \" + ns.getString(\"regexp\"), e);\n        return false;\n      }\n      m_Invert = ns.getBoolean(\"invert\");\n    }\n    return result;\n  }\n\n  protected String doIntercept(String line, boolean stdout) {\n    if ((!m_Invert && m_RegExp.matcher(line).matches())\n      || (m_Invert && !m_RegExp.matcher(line).matches())) {\n      return line;\n    }\n    return null;\n  }\n}\n\n\n\n\nUser interface\n\n\nFor adding a command in the user interface, you have to subclass the\nabstract class \ncom.github.fracpete.wekavirtualenv.gui.command.AbstractGUICommand\n\nand place the class in the \ncom.github.fracpete.wekavirtualenv.gui.command\n package.\n\n\nIf you want to capture the output of the process, then let the method\n\ngeneratesOutput()\n return \ntrue\n.\n\n\nIf you the command is to be run in the context of a Weka environment, then\nthe method \nrequiresEnvironment()\n needs to return \ntrue\n. \nMethods that return \ntrue\n automatically show up in the drop-down list of\nan environment. Ones that return \nfalse\n, show up in the main menu.\n\n\nThe \ndestroy()\n method is used for stopping any process that got launched.\n\n\nHere is the code for launching the Weka Explorer, which requires an environment\nand also captures the output of the launched process:\n\n\npublic class Explorer\n  extends AbstractGUICommand {\n\n  protected com.github.fracpete.wekavirtualenv.command.Explorer m_Command;\n\n  public String getName() {\n    return \"Explorer\";\n  }\n\n  public String getGroup() {\n    return \"gui\";\n  }\n\n  public boolean requiresEnvironment() {\n    return true;\n  }\n\n  public boolean generatesOutput() {\n    return true;\n  }\n\n  @Override\n  protected String doExecute() {\n    String result = null;\n    m_Command = new com.github.fracpete.wekavirtualenv.command.Explorer();\n    m_Command.setEnv(m_Environment);\n    transferOutputListeners(m_Command);\n    if (!m_Command.execute(new String[0])) {\n      if (m_Command.hasErrors())\n        result = m_Command.getErrors();\n      else\n        result = \"Failed to launch Explorer!\";\n    }\n    m_Command = null;\n    return result;\n  }\n\n  public void destroy() {\n    if (m_Command != null)\n      m_Command.destroy();\n  }\n}",
            "title": "Extend"
        },
        {
            "location": "/extend/#automatic-class-discovery",
            "text": "Thanks to the automatic class discovery (provided by  jclasslocator ), you don't have\nto register anything, you only have to place the command in the same package\nas the abstract superclass or interface.",
            "title": "Automatic class discovery"
        },
        {
            "location": "/extend/#command-line",
            "text": "It is quite easy to add new commands to the tool:   create a class derived from  com.github.fracpete.wekavirtualenv.command.AbstractCommand  place the class in package  com.github.fracpete.wekavirtualenv.command",
            "title": "Command-line"
        },
        {
            "location": "/extend/#dataset-filenames",
            "text": "If your command should handle additional arguments as dataset filenames, then\nimplement the indicator interface  com.github.fracpete.wekavirtualenv.command.DatasetHandler .  This interface is used by the  com.github.fracpete.wekavirtualenv.gui.ArffCommandSelector \ntool, listing all the tools in the dropdown box that implement this interface.\nBy default, these are by default only the  Explorer  and  ArffViewer .",
            "title": "Dataset filenames"
        },
        {
            "location": "/extend/#handling-arguments",
            "text": "The  Delete  command just takes a single option, which is the name of the\nenvironment to delete. In order for the parsing to work, you have to define\na  ArgumentParser  object in the  getParser  method and then access the\nparsed options in the  doExecute  method, using the  Namespace  object.  Here is the  Delete  command's code:  public class Delete extends AbstractCommand {\n\n  public String getName() {\n    return \"delete\";\n  }\n\n  public String getHelp() {\n    return \"Deletes an existing environment.\";\n  }\n\n  public ArgumentParser getParser() {\n    ArgumentParser result = new ArgumentParser(getName());\n    result.addOption(\"--name\")\n      .dest(\"name\")\n      .help(\"the name of the environment to delete\")\n      .required(true);\n    return result;\n  }\n\n  protected boolean doExecute(Namespace ns, String[] options) {\n    String msg = Environments.delete(ns.getString(\"name\"));\n    if (msg != null)\n      addError(\"Failed to delete environment '\" + ns.getString(\"name\") + \"':\\n\" + msg);\n    else\n      System.out.println(\"Environment successfully deleted: \" + ns.getString(\"name\"));\n    return (msg == null);\n  }\n}  For more information on the parsing, check out the  simple-argparse4j \nproject page.",
            "title": "Handling arguments"
        },
        {
            "location": "/extend/#executing-class-with-main-method",
            "text": "The  AbstractLaunchCommand  class makes it easier to execute a class that\nhas a  main  method.  The class for launching the Weka Explorer is quite simple:  public class Explorer extends AbstractLaunchCommand implements DatasetHandler {\n\n  public String getName() {\n    return \"explorer\";\n  }\n\n  public String getHelp() {\n    return \"Launches the Weka Explorer.\\n\"\n      + \"You can supply a dataset filename to load immediately in the Explorer.\";\n  }\n\n  public boolean supportsAdditionalArguments() {\n    return true;\n  }\n\n  protected boolean doExecute(Namespace ns, String[] options) {\n    return launch(build(\"weka.gui.explorer.Explorer\", options));\n  }\n}  In the  doExecute  method, the  build  method takes the class name and any\noptions that the class should process. In the Explorer's case an optional \ndataset to load.",
            "title": "Executing class with main method"
        },
        {
            "location": "/extend/#script-command",
            "text": "If you want to add a script command, you just have to derive it from the com.github.fracpete.wekavirtualenv.command.script.AbstractScriptCommand \nsuper class and place it in the  com.github.fracpete.wekavirtualenv.command.script \npackage.  Here is the code for the  DirName  command:  public class DirName extends AbstractScriptCommand {\n\n  public String getName() {\n    return \"dir_name\";\n  }\n\n  public String getHelp() {\n    return \"Extracts the path from the specified file variable.\";\n  }\n\n  public ArgumentParser getParser() {\n    ArgumentParser result = new ArgumentParser(getName());\n    result.addOption(\"--file\")\n      .dest(\"file\")\n      .help(\"the full path to extract the path from.\")\n      .required(true);\n    result.addOption(\"--dest\")\n      .dest(\"dest\")\n      .help(\"the name of the variable to store the result in.\")\n      .required(true);\n    return result;\n  }\n\n  protected boolean evalCommand(Namespace ns, String[] options) {\n    File file = new File(ns.getString(\"file\"));\n    getContext().getVariables().set(ns.getString(\"dest\"), file.getParentFile().getAbsolutePath());\n    return true;\n  }\n}",
            "title": "Script command"
        },
        {
            "location": "/extend/#filter",
            "text": "If you want to add a custom output filter (like grep or tee), then you only\nhave to implement the  com.github.fracpete.wekavirtualenv.command.filter.Filter \ninterface (or use the abstract superclass  AbstractFilter  for convenience)\nand place it in the  com.github.fracpete.wekavirtualenv.command.filter  package.  Here is the code for the  Grep  filter:  public class Grep\n  extends AbstractFilter {\n\n  /** the pattern for matching. */\n  protected Pattern m_RegExp;\n\n  protected boolean m_Invert;\n\n  public String getName() {\n    return \"grep\";\n  }\n\n  @Override\n  public String getHelp() {\n    return \"For capturing strings that match a regular expression.\";\n  }\n\n  public ArgumentParser getParser() {\n    ArgumentParser result = super.getParser();\n    result.addOption(\"--regexp\")\n      .dest(\"regexp\")\n      .help(\"the regular expression that the output must match to be kept.\")\n      .required(true);\n    result.addOption(\"--invert\")\n      .dest(\"invert\")\n      .help(\"whether to invert the matching sense.\")\n      .argument(false);\n    return result;\n  }\n\n  public boolean initialize(Namespace ns) {\n    boolean result = super.initialize(ns);\n    if (result) {\n      try {\n    m_RegExp = Pattern.compile(ns.getString(\"regexp\"));\n      }\n      catch (Exception e) {\n        addError(\"Invalid regular expression: \" + ns.getString(\"regexp\"), e);\n        return false;\n      }\n      m_Invert = ns.getBoolean(\"invert\");\n    }\n    return result;\n  }\n\n  protected String doIntercept(String line, boolean stdout) {\n    if ((!m_Invert && m_RegExp.matcher(line).matches())\n      || (m_Invert && !m_RegExp.matcher(line).matches())) {\n      return line;\n    }\n    return null;\n  }\n}",
            "title": "Filter"
        },
        {
            "location": "/extend/#user-interface",
            "text": "For adding a command in the user interface, you have to subclass the\nabstract class  com.github.fracpete.wekavirtualenv.gui.command.AbstractGUICommand \nand place the class in the  com.github.fracpete.wekavirtualenv.gui.command  package.  If you want to capture the output of the process, then let the method generatesOutput()  return  true .  If you the command is to be run in the context of a Weka environment, then\nthe method  requiresEnvironment()  needs to return  true . \nMethods that return  true  automatically show up in the drop-down list of\nan environment. Ones that return  false , show up in the main menu.  The  destroy()  method is used for stopping any process that got launched.  Here is the code for launching the Weka Explorer, which requires an environment\nand also captures the output of the launched process:  public class Explorer\n  extends AbstractGUICommand {\n\n  protected com.github.fracpete.wekavirtualenv.command.Explorer m_Command;\n\n  public String getName() {\n    return \"Explorer\";\n  }\n\n  public String getGroup() {\n    return \"gui\";\n  }\n\n  public boolean requiresEnvironment() {\n    return true;\n  }\n\n  public boolean generatesOutput() {\n    return true;\n  }\n\n  @Override\n  protected String doExecute() {\n    String result = null;\n    m_Command = new com.github.fracpete.wekavirtualenv.command.Explorer();\n    m_Command.setEnv(m_Environment);\n    transferOutputListeners(m_Command);\n    if (!m_Command.execute(new String[0])) {\n      if (m_Command.hasErrors())\n        result = m_Command.getErrors();\n      else\n        result = \"Failed to launch Explorer!\";\n    }\n    m_Command = null;\n    return result;\n  }\n\n  public void destroy() {\n    if (m_Command != null)\n      m_Command.destroy();\n  }\n}",
            "title": "User interface"
        },
        {
            "location": "/examples/",
            "text": "Note for Windows users:\n Use \nwenv.bat\n instead of \nwenv.sh\n from the \nbin\n \ndirectory for the following examples. Also, remove the trailing backslashes\nin the commands and place the whole command on a single line.\n\n\nInstalling Weka\n\n\nUsing the \ninstall\n command, you can download and install versions of Weka.\nA platform-independent zip is downloaded and unzipped to a directory that you\nspecify. Each zip file contains a directory with the Weka version, so you only\nneed to supply a top-level directory as the installation directory.\n\n\nTo start with, you need to update the list of available updates (downloads\na CSV file from github.com):\n\n\nwenv.sh install \\\n  --action update\n\n\n\n\nOnce downloaded, you can list the versions for which we have download links:\n\n\nwenv.sh install \\\n  --action list\n\n\n\n\nThis will output something like this:\n\n\nAvailable versions:\n3.6.0\n...\n3.7.13\n3.8.0\n3.8.1\n3.8.2\n3.9.0\n3.9.1\n3.9.2\n\n\n\n\nChoose a version and install it in a directory, e.g., \n/home/fracpete/weka\n:\n\n\nwenv.sh install \\\n  --action download \\\n  --version 3.6.10 \\\n  --install-dir /home/fracpete/weka\n\n\n\n\nOnce successfully finished, you will have the following directory containing\nWeka 3.6.10:\n\n\n/home/fracpete/weka/weka-3-6-10\n\n\n\n\nYou can use this directory now for environments.\n\n\nEnvironments\n\n\nCreate an environment for Weka 3.8.1:\n\n\nwenv.sh create \\\n  --name weka381 \\\n  --weka /home/fracpete/programs/weka/weka-3-8-1/weka.jar\n\n\n\n\nCreate an environment for Weka 3.9.1 with a custom java binary to use\nand 4GB of heap size:\n\n\nwenv.sh create \\\n  --name weka391 \\\n  --weka /home/fracpete/programs/weka/weka-3-9-1/weka.jar \\\n  --java /home/fracpete/programs/jdk/jdk1.8.0_144-64bit/bin/java \\\n  --memory 4g\n\n\n\n\nLaunching user interfaces\n\n\nLaunch the GUIChooser from the \nweka381\n environment:\n\n\nwenv.sh guichooser weka381\n\n\n\n\nLaunch the Explorer from the \nweka391\n environment:\n\n\nwenv.sh explorer weka391\n\n\n\n\nExecuting classes\n\n\nCross-validate J48 from the \nweka381\n environment on the \niris\n dataset:\n\n\nwenv.sh run weka381 --class weka.classifiers.trees.J48 \\\n  -t /home/fracpete/development/datasets/uci/nominal/iris.arff\n\n\n\n\nAliases (global)\n\n\nCreate a global alias called \nj48\n:\n\n\nwenv.sh alias-add --name j48 run --class weka.classifiers.trees.J48 -C 0.3\n\n\n\n\nIf the command of a global alias requires an environment for executing, then\nthe environment needs to get injected via the \n--inject-env\n option. \nThe following command executes the global alias \nj48\n, cross-validating the \n\nJ48\n classifier on the UCI dataset \niris\n:\n\n\nwenv.sh alias-exec --inject-env weka381 --name j48 -t iris.arff\n\n\n\n\nAliases (environment-specific)\n\n\nCreate an alias called \nj48\n in the \nweka381\n environment:\n\n\nwenv.sh alias-add --env weka381 --name j48 run --class weka.classifiers.trees.J48 -C 0.3\n\n\n\n\nThe following command executes the alias \nj48\n from the \nweka381\n environment, \ncross-validating the \nJ48\n classifier on the UCI dataset \niris\n:\n\n\nwenv.sh alias-exec --env weka381 --name j48 -t iris.arff\n\n\n\n\nAliases (list)\n\n\nYou can list all aliases, global and for all environments, as follows:\n\n\nwenv.sh alias-list --all\n\n\n\n\nWhich will output something like this:\n\n\nEnvironment | Name | Command                                      \n------------+------+----------------------------------------------\n<global>    | j48  | run --class weka.classifiers.trees.J48 -C 0.3\nweka381     | j48  | run -class weka.classifiers.trees.J48 -C 0.3 \n\n\n\n\nYou can list all global aliases as follows:\n\n\nwenv.sh alias-list\n\n\n\n\nYou can list the aliases for environment \nweka381\n as follows:\n\n\nwenv.sh alias-list --env weka381\n\n\n\n\nEnvironment locations\n\n\nThe environments get created in the following directory:\n\n\n\n\n\n\nUnix (Linux, Mac)\n\n\n$HOME/.local/share/wekavirtualenv\n\n\n\n\n\n\nWindows\n\n\n%USERPROFILE%\\wekavirtualenv",
            "title": "Examples"
        },
        {
            "location": "/examples/#installing-weka",
            "text": "Using the  install  command, you can download and install versions of Weka.\nA platform-independent zip is downloaded and unzipped to a directory that you\nspecify. Each zip file contains a directory with the Weka version, so you only\nneed to supply a top-level directory as the installation directory.  To start with, you need to update the list of available updates (downloads\na CSV file from github.com):  wenv.sh install \\\n  --action update  Once downloaded, you can list the versions for which we have download links:  wenv.sh install \\\n  --action list  This will output something like this:  Available versions:\n3.6.0\n...\n3.7.13\n3.8.0\n3.8.1\n3.8.2\n3.9.0\n3.9.1\n3.9.2  Choose a version and install it in a directory, e.g.,  /home/fracpete/weka :  wenv.sh install \\\n  --action download \\\n  --version 3.6.10 \\\n  --install-dir /home/fracpete/weka  Once successfully finished, you will have the following directory containing\nWeka 3.6.10:  /home/fracpete/weka/weka-3-6-10  You can use this directory now for environments.",
            "title": "Installing Weka"
        },
        {
            "location": "/examples/#environments",
            "text": "Create an environment for Weka 3.8.1:  wenv.sh create \\\n  --name weka381 \\\n  --weka /home/fracpete/programs/weka/weka-3-8-1/weka.jar  Create an environment for Weka 3.9.1 with a custom java binary to use\nand 4GB of heap size:  wenv.sh create \\\n  --name weka391 \\\n  --weka /home/fracpete/programs/weka/weka-3-9-1/weka.jar \\\n  --java /home/fracpete/programs/jdk/jdk1.8.0_144-64bit/bin/java \\\n  --memory 4g",
            "title": "Environments"
        },
        {
            "location": "/examples/#launching-user-interfaces",
            "text": "Launch the GUIChooser from the  weka381  environment:  wenv.sh guichooser weka381  Launch the Explorer from the  weka391  environment:  wenv.sh explorer weka391",
            "title": "Launching user interfaces"
        },
        {
            "location": "/examples/#executing-classes",
            "text": "Cross-validate J48 from the  weka381  environment on the  iris  dataset:  wenv.sh run weka381 --class weka.classifiers.trees.J48 \\\n  -t /home/fracpete/development/datasets/uci/nominal/iris.arff",
            "title": "Executing classes"
        },
        {
            "location": "/examples/#aliases-global",
            "text": "Create a global alias called  j48 :  wenv.sh alias-add --name j48 run --class weka.classifiers.trees.J48 -C 0.3  If the command of a global alias requires an environment for executing, then\nthe environment needs to get injected via the  --inject-env  option. \nThe following command executes the global alias  j48 , cross-validating the  J48  classifier on the UCI dataset  iris :  wenv.sh alias-exec --inject-env weka381 --name j48 -t iris.arff",
            "title": "Aliases (global)"
        },
        {
            "location": "/examples/#aliases-environment-specific",
            "text": "Create an alias called  j48  in the  weka381  environment:  wenv.sh alias-add --env weka381 --name j48 run --class weka.classifiers.trees.J48 -C 0.3  The following command executes the alias  j48  from the  weka381  environment, \ncross-validating the  J48  classifier on the UCI dataset  iris :  wenv.sh alias-exec --env weka381 --name j48 -t iris.arff",
            "title": "Aliases (environment-specific)"
        },
        {
            "location": "/examples/#aliases-list",
            "text": "You can list all aliases, global and for all environments, as follows:  wenv.sh alias-list --all  Which will output something like this:  Environment | Name | Command                                      \n------------+------+----------------------------------------------\n<global>    | j48  | run --class weka.classifiers.trees.J48 -C 0.3\nweka381     | j48  | run -class weka.classifiers.trees.J48 -C 0.3   You can list all global aliases as follows:  wenv.sh alias-list  You can list the aliases for environment  weka381  as follows:  wenv.sh alias-list --env weka381",
            "title": "Aliases (list)"
        },
        {
            "location": "/examples/#environment-locations",
            "text": "The environments get created in the following directory:    Unix (Linux, Mac)  $HOME/.local/share/wekavirtualenv    Windows  %USERPROFILE%\\wekavirtualenv",
            "title": "Environment locations"
        },
        {
            "location": "/scripting/",
            "text": "With the \nscript\n command, you can execute simple scripts stored in text\nfiles, enhancing the existing command-line commands with special script \ncommands and output filters. Script commands allow you to search for files\nor directories, store and remove variables, iterate variable arrays, etc.\nOutput filters are used to filter the output of commands, e.g., restrict\nthe information output or redirect it to a file.\n\n\nScript variables are of the format \n${name}\n, with \nname\n being the name\nof the variable. Environment variables are of the format \n@{name}\n. \nVariables get automatically replaced in commands before these get executed.\n\n\nThe following script iterates through all ARFF files in directory \n\n/home/fracpete/development/datasets/uci/nominal\n\nand cross-validates J48 on it. From the output generated by J48, only\nthe lines containing \nTime taken\n, \nCorrectly Classified\n and \nRoot mean squared\n\nare filtered out, using the \ngrep\n filter. This output is then also stored\nin the file \n/home/fracpete/j48.txt\n, using the \ntee\n filter.\n\n\nIn order to make scripts more readable, especially when performing filtering,\nlong lines can be broken down into multiple ones by ending them all but the\nlast one with a backslash (\n\\\n). \n\n\nEmpty lines are skipped, as well as comment lines starting with \n#\n.\n\n\n# setup\nset searchdir=/home/fracpete/development/datasets/uci/nominal\nset outfile=/home/fracpete/j48.txt\nset env=weka392\n\n# search for arff files\necho --message \"\\nsearch dir: ${searchdir}\"\nlist_files --dir ${searchdir} --regexp \".*\\.arff\" --dest files\n\n# evaluate J48 on each of the arff files and output accuracy in text file\nforeach --iterate files --dest file\n  echo --message \"\\n--> ${file}\" | tee --stdout --append --output ${outfile}\n  run ${env} --class weka.classifiers.trees.J48 -t ${file} \\\n     | grep --stdout --regexp \".*(Time taken|Correctly Classified|Root mean squared).*\" \\\n     | tee --stdout --append --output ${outfile}\n\n\n\n\nHelp\n\n\nIf you want to get more help on filters, use the following commands:\n\n\n\n\nfilter_help\n -- outputs a list of all available filters \n\n\nfilter_help --filter <name>\n -- outputs a detailed help screen for the named filter\n\n\n\n\nIf you want to get more help on script commands, use the following commands:\n\n\n\n\nscript_help\n -- outputs a list of all available script commands\n\n\nscript_help --cmd <name>\n -- outputs a detailed help screen for the named script command\n\n\n\n\nScript commands\n\n\nThe following script commands are available:\n\n\nAvailable script commands:\n\nbase_name <options>\n    Extracts the file name without the path from the specified variable.\n\ncalc <options>\n    Calculates the result of a mathematical expression.\n\ndel_dir <options>\n    Deletes the specified directory (recursively).\n\ndel_file <options>\n    Deletes the specified file.\n\ndir_name <options>\n    Extracts the path from the specified file variable.\n\ndump_vars\n    Just outputs all the currently set variables.\n\nflatten <options>\n    Flattens an array variable into a single string variable.\n\nfor <options>\n    Iterates through the numeric values from lower to upper bound, using the specified step amount.\n\nforeach <options>\n    Iterates through the elements of a variable and executes the nested instructions.\n\nlist_dirs <options>\n    Locates directories in specified directory and stores them in a variable.\n    Search can be recursive, directory names (excl parent path) can be matched again regular expression.\n\nlist_files <options>\n    Locates files in specified directory and stores them in a variable.\n    Search can be recursive, file names (excl path) can be matched again regular expression.\n\nread_lines <options>\n    Reads all the lines in a text file into a variable.\n    Can skip empty lines and lines that match regular expression.\n\nreplace <options>\n    Performs string replacement, simple or regular expression based.\n    If no replacement string is provided the empty string is used.\n\nreplace_ext <options>\n    Replaces the extension of the file stored in the variable with the supplied one.\n\nset <args>\n    Sets a variable in the form of 'name=value'.\n    The value can contain other variables, which will get evaluated in a lazy fashion.\n\nsplit <options>\n    Splits a string variable into a string array variable.\n\nunset <args>\n    Removes the specified variable.\n\n\nNotes:\n<options>\n    the command supports additional options,\n    specify the script's name to output detailed help.\n<args>\n    the command supports additional arguments\n    see script's help.\n\n\n\n\nOutput filters\n\n\nThe following output filters are available:\n\n\nAvailable filters:\n\ngrep <options>\n    For capturing strings that match a regular expression.\n\nreplace <options>\n    Performs string replacement, simple or regular expression based.\n\ntee <options>\n    Tees off the output to a file.\n\n\nNotes:\n<options>\n    the filter supports additional options,\n    specify the filter's name to output detailed help.",
            "title": "Scripting"
        },
        {
            "location": "/scripting/#help",
            "text": "If you want to get more help on filters, use the following commands:   filter_help  -- outputs a list of all available filters   filter_help --filter <name>  -- outputs a detailed help screen for the named filter   If you want to get more help on script commands, use the following commands:   script_help  -- outputs a list of all available script commands  script_help --cmd <name>  -- outputs a detailed help screen for the named script command",
            "title": "Help"
        },
        {
            "location": "/scripting/#script-commands",
            "text": "The following script commands are available:  Available script commands:\n\nbase_name <options>\n    Extracts the file name without the path from the specified variable.\n\ncalc <options>\n    Calculates the result of a mathematical expression.\n\ndel_dir <options>\n    Deletes the specified directory (recursively).\n\ndel_file <options>\n    Deletes the specified file.\n\ndir_name <options>\n    Extracts the path from the specified file variable.\n\ndump_vars\n    Just outputs all the currently set variables.\n\nflatten <options>\n    Flattens an array variable into a single string variable.\n\nfor <options>\n    Iterates through the numeric values from lower to upper bound, using the specified step amount.\n\nforeach <options>\n    Iterates through the elements of a variable and executes the nested instructions.\n\nlist_dirs <options>\n    Locates directories in specified directory and stores them in a variable.\n    Search can be recursive, directory names (excl parent path) can be matched again regular expression.\n\nlist_files <options>\n    Locates files in specified directory and stores them in a variable.\n    Search can be recursive, file names (excl path) can be matched again regular expression.\n\nread_lines <options>\n    Reads all the lines in a text file into a variable.\n    Can skip empty lines and lines that match regular expression.\n\nreplace <options>\n    Performs string replacement, simple or regular expression based.\n    If no replacement string is provided the empty string is used.\n\nreplace_ext <options>\n    Replaces the extension of the file stored in the variable with the supplied one.\n\nset <args>\n    Sets a variable in the form of 'name=value'.\n    The value can contain other variables, which will get evaluated in a lazy fashion.\n\nsplit <options>\n    Splits a string variable into a string array variable.\n\nunset <args>\n    Removes the specified variable.\n\n\nNotes:\n<options>\n    the command supports additional options,\n    specify the script's name to output detailed help.\n<args>\n    the command supports additional arguments\n    see script's help.",
            "title": "Script commands"
        },
        {
            "location": "/scripting/#output-filters",
            "text": "The following output filters are available:  Available filters:\n\ngrep <options>\n    For capturing strings that match a regular expression.\n\nreplace <options>\n    Performs string replacement, simple or regular expression based.\n\ntee <options>\n    Tees off the output to a file.\n\n\nNotes:\n<options>\n    the filter supports additional options,\n    specify the filter's name to output detailed help.",
            "title": "Output filters"
        },
        {
            "location": "/maven/",
            "text": "Add the following dependency to your \npom.xml\n:\n\n\n  <dependency>\n    <groupId>com.github.fracpete</groupId>\n    <artifactId>weka-virtualenv</artifactId>\n    <version>0.0.17</version>\n  </dependency>",
            "title": "Maven"
        },
        {
            "location": "/releases/",
            "text": "The following releases are available:\n\n\n\n\n0.0.17\n\n\n0.0.16\n\n\n0.0.15\n\n\n0.0.14\n\n\n0.0.13\n\n\n0.0.12\n\n\n0.0.11\n\n\n0.0.10\n\n\n0.0.9\n\n\n0.0.8\n\n\n0.0.7\n\n\n0.0.4\n\n\n0.0.3\n\n\n0.0.2",
            "title": "Releases"
        }
    ]
}