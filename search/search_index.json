{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Virtual environment manager for Weka, inspired by the extremely useful virtual environments that Python supports. weka-virtualenv can be used for launching the GUI or arbitrary Weka classes. Since weka-virtualenv uses options starting with double-dashes ( -- ), clashes with Weka options are avoided. Any option that wasn't consumed by weka-virtualenv will get further processed by the command. E.g., when launching the Explorer using the explorer command, a dataset can be supplied to load immediately, or, when executing a classifier using the run command, any additional option will get passed to the Weka class. You can use the tool either through the command-line or through its user interface. Some basic scripting support is available through the script command-line command (see Scripting section). How it works The tool simply uses existing Weka functionality, namely the WEKA_HOME environment variable, for separating the various environments. When launching a class or GUI tool, it launches a new Java process with the WEKA_HOME environment variable pointing to the current environment's wekafiles directory. If an environment has no Java or heap size configure ( <default> ), then it just uses the system's default settings for launching the new process. User interface You can start the GUI with the following script from the bin directory: Linux/Mac: wenvgui.sh Windows: wenvgui.bat Arff Command Selector This little tool lets you choose environment and application (Explorer or Arff Viewer) to launch, using the provided dataset filenames (e.g., Open with from the right-click mouse context menu): Linux/Mac: wenvarff.sh Windows: wenvarff.bat Videos You can find videos for the tool in the following YouTube playlist: weka-virtualenv playlist Windows users just have to substitute the wenv.sh and wenvgui.sh scripts with wenv.bat and wenvgui.bat . For adding the tool's bin directory to your PATH environment variable (to make it available from the command prompt), follow these instructions .","title":"Home"},{"location":"#how-it-works","text":"The tool simply uses existing Weka functionality, namely the WEKA_HOME environment variable, for separating the various environments. When launching a class or GUI tool, it launches a new Java process with the WEKA_HOME environment variable pointing to the current environment's wekafiles directory. If an environment has no Java or heap size configure ( <default> ), then it just uses the system's default settings for launching the new process.","title":"How it works"},{"location":"#user-interface","text":"You can start the GUI with the following script from the bin directory: Linux/Mac: wenvgui.sh Windows: wenvgui.bat","title":"User interface"},{"location":"#arff-command-selector","text":"This little tool lets you choose environment and application (Explorer or Arff Viewer) to launch, using the provided dataset filenames (e.g., Open with from the right-click mouse context menu): Linux/Mac: wenvarff.sh Windows: wenvarff.bat","title":"Arff Command Selector"},{"location":"#videos","text":"You can find videos for the tool in the following YouTube playlist: weka-virtualenv playlist Windows users just have to substitute the wenv.sh and wenvgui.sh scripts with wenv.bat and wenvgui.bat . For adding the tool's bin directory to your PATH environment variable (to make it available from the command prompt), follow these instructions .","title":"Videos"},{"location":"commands/","text":"Available commands: alias-add <options> <args> Adds an alias definition, i.e., shortcut for command and options. All options not consumed by this command will get used as options for the alias. No checks are being performed on the correctness. alias-del <options> Removes an alias definition. alias-exec <options> <args> Executes an alias definition, i.e., shortcut for command and options. All options not consumed by this command will get used as additional options for the alias. No checks are being performed on the correctness. alias-list <options> Lists aliases and their associated options. Listing can be for global aliases, per environment, or for all. arffviewer <env> <args> | output filter(s) Launches the Weka Arff viewer. You can supply dataset filenames to load immediately in the viewer. clone <options> Clones an existing environment. Allows adjusting of environment parameters. create <options> Creates a new environment. Can be initialized with the content of an existing 'wekafiles' directory. Additional classpath elements can be injected via the CLASSPATH environment that you can define with the '--envvar' option. delete <options> Deletes an existing environment. echo <options> | output filter(s) Outputs the specified message. experimenter <env> <args> | output filter(s) Launches the Weka Experimenter. explorer <env> <args> | output filter(s) Launches the Weka Explorer. You can supply a dataset filename to load immediately in the Explorer. filter_help <options> Prints help on the available output filters. guichooser <env> | output filter(s) Launches the Weka GUIChooser. help Outputs help information. install <options> Downloads and installs a specific Weka version. NB: The downloaded zip file contains a sub-directory with the version of Weka. knowledgeflow <env> <args> | output filter(s) Launches the Weka KnowledgeFlow. You can supply a flow file to load immediately. list_cmds Lists all available commands. list_envs <options> Lists all available environments. list_pkgs <env> <options> | output filter(s) Lists Weka packages: all, installed or available ones. pkgmgr <env> <args> | output filter(s) Executes the commandline package manager. You can supply additional options to the package manager, like '-list-packages'. pkgmgr-gui <env> | output filter(s) Launches the package manager user interface. proxy <options> For managing proxy settings: listing, setting, removing. reset <options> Resets an existing environment, i.e., deletes the \"wekafiles\" sub-directory. run <env> <options> <args> | output filter(s) Executes an arbitrary class with the unconsumed command-line options. script <options> Executes the commands in the specified script file. Empty lines and lines starting with # get skipped. script_help <options> Prints help on the available script commands. sqlviewer <env> | output filter(s) Launches the Weka SQL Viewer. status Outputs some status information. update <env> <options> Allows adjusting of parameters of an existing environment. workbench <env> | output filter(s) Launches the Weka Workbench. Notes: <env> the name of the environment to use for the command. <options> the command supports additional options, you can use --help as argument to see further details. <args> the command passes on all unconsumed options to the underlying process | output filter(s) the command generates output which can filtered, these filters can be chained, one '|' per filter","title":"Commands"},{"location":"examples/","text":"Note for Windows users: Use wenv.bat instead of wenv.sh from the bin directory for the following examples. Also, remove the trailing backslashes in the commands and place the whole command on a single line. Installing Weka Using the install command, you can download and install versions of Weka. A platform-independent zip is downloaded and unzipped to a directory that you specify. Each zip file contains a directory with the Weka version, so you only need to supply a top-level directory as the installation directory. To start with, you need to update the list of available updates (downloads a CSV file from github.com): wenv.sh install \\ --action update Once downloaded, you can list the versions for which we have download links: wenv.sh install \\ --action list This will output something like this: Available versions: 3.6.0 ... 3.7.13 3.8.0 3.8.1 3.8.2 3.9.0 3.9.1 3.9.2 Choose a version and install it in a directory, e.g., /home/fracpete/weka : wenv.sh install \\ --action download \\ --version 3.6.10 \\ --install-dir /home/fracpete/weka Once successfully finished, you will have the following directory containing Weka 3.6.10: /home/fracpete/weka/weka-3-6-10 You can use this directory now for environments. Environments Create an environment for Weka 3.8.1: wenv.sh create \\ --name weka381 \\ --weka /home/fracpete/programs/weka/weka-3-8-1/weka.jar Create an environment for Weka 3.9.1 with a custom java binary to use and 4GB of heap size: wenv.sh create \\ --name weka391 \\ --weka /home/fracpete/programs/weka/weka-3-9-1/weka.jar \\ --java /home/fracpete/programs/jdk/jdk1.8.0_144-64bit/bin/java \\ --memory 4g Custom CLASSPATH: It is possible to inject custom jars, which will precede the weka.jar of the environment. For this, you only need to define the CLASSPATH environment variable (via --envvar ) when creating (or updating) an environment. Launching user interfaces Launch the GUIChooser from the weka381 environment: wenv.sh guichooser weka381 Launch the Explorer from the weka391 environment: wenv.sh explorer weka391 Executing classes Cross-validate J48 from the weka381 environment on the iris dataset: wenv.sh run weka381 --class weka.classifiers.trees.J48 \\ -t /home/fracpete/development/datasets/uci/nominal/iris.arff Aliases (global) Create a global alias called j48 : wenv.sh alias-add --name j48 run --class weka.classifiers.trees.J48 -C 0.3 If the command of a global alias requires an environment for executing, then the environment needs to get injected via the --inject-env option. The following command executes the global alias j48 , cross-validating the J48 classifier on the UCI dataset iris : wenv.sh alias-exec --inject-env weka381 --name j48 -t iris.arff Aliases (environment-specific) Create an alias called j48 in the weka381 environment: wenv.sh alias-add --env weka381 --name j48 run --class weka.classifiers.trees.J48 -C 0.3 The following command executes the alias j48 from the weka381 environment, cross-validating the J48 classifier on the UCI dataset iris : wenv.sh alias-exec --env weka381 --name j48 -t iris.arff Aliases (list) You can list all aliases, global and for all environments, as follows: wenv.sh alias-list --all Which will output something like this: Environment | Name | Command ------------+------+---------------------------------------------- <global> | j48 | run --class weka.classifiers.trees.J48 -C 0.3 weka381 | j48 | run -class weka.classifiers.trees.J48 -C 0.3 You can list all global aliases as follows: wenv.sh alias-list You can list the aliases for environment weka381 as follows: wenv.sh alias-list --env weka381 Environment locations The environments get created in the following directory: Unix (Linux, Mac) $HOME/.local/share/wekavirtualenv Windows %USERPROFILE%\\wekavirtualenv","title":"Examples"},{"location":"examples/#installing-weka","text":"Using the install command, you can download and install versions of Weka. A platform-independent zip is downloaded and unzipped to a directory that you specify. Each zip file contains a directory with the Weka version, so you only need to supply a top-level directory as the installation directory. To start with, you need to update the list of available updates (downloads a CSV file from github.com): wenv.sh install \\ --action update Once downloaded, you can list the versions for which we have download links: wenv.sh install \\ --action list This will output something like this: Available versions: 3.6.0 ... 3.7.13 3.8.0 3.8.1 3.8.2 3.9.0 3.9.1 3.9.2 Choose a version and install it in a directory, e.g., /home/fracpete/weka : wenv.sh install \\ --action download \\ --version 3.6.10 \\ --install-dir /home/fracpete/weka Once successfully finished, you will have the following directory containing Weka 3.6.10: /home/fracpete/weka/weka-3-6-10 You can use this directory now for environments.","title":"Installing Weka"},{"location":"examples/#environments","text":"Create an environment for Weka 3.8.1: wenv.sh create \\ --name weka381 \\ --weka /home/fracpete/programs/weka/weka-3-8-1/weka.jar Create an environment for Weka 3.9.1 with a custom java binary to use and 4GB of heap size: wenv.sh create \\ --name weka391 \\ --weka /home/fracpete/programs/weka/weka-3-9-1/weka.jar \\ --java /home/fracpete/programs/jdk/jdk1.8.0_144-64bit/bin/java \\ --memory 4g Custom CLASSPATH: It is possible to inject custom jars, which will precede the weka.jar of the environment. For this, you only need to define the CLASSPATH environment variable (via --envvar ) when creating (or updating) an environment.","title":"Environments"},{"location":"examples/#launching-user-interfaces","text":"Launch the GUIChooser from the weka381 environment: wenv.sh guichooser weka381 Launch the Explorer from the weka391 environment: wenv.sh explorer weka391","title":"Launching user interfaces"},{"location":"examples/#executing-classes","text":"Cross-validate J48 from the weka381 environment on the iris dataset: wenv.sh run weka381 --class weka.classifiers.trees.J48 \\ -t /home/fracpete/development/datasets/uci/nominal/iris.arff","title":"Executing classes"},{"location":"examples/#aliases-global","text":"Create a global alias called j48 : wenv.sh alias-add --name j48 run --class weka.classifiers.trees.J48 -C 0.3 If the command of a global alias requires an environment for executing, then the environment needs to get injected via the --inject-env option. The following command executes the global alias j48 , cross-validating the J48 classifier on the UCI dataset iris : wenv.sh alias-exec --inject-env weka381 --name j48 -t iris.arff","title":"Aliases (global)"},{"location":"examples/#aliases-environment-specific","text":"Create an alias called j48 in the weka381 environment: wenv.sh alias-add --env weka381 --name j48 run --class weka.classifiers.trees.J48 -C 0.3 The following command executes the alias j48 from the weka381 environment, cross-validating the J48 classifier on the UCI dataset iris : wenv.sh alias-exec --env weka381 --name j48 -t iris.arff","title":"Aliases (environment-specific)"},{"location":"examples/#aliases-list","text":"You can list all aliases, global and for all environments, as follows: wenv.sh alias-list --all Which will output something like this: Environment | Name | Command ------------+------+---------------------------------------------- <global> | j48 | run --class weka.classifiers.trees.J48 -C 0.3 weka381 | j48 | run -class weka.classifiers.trees.J48 -C 0.3 You can list all global aliases as follows: wenv.sh alias-list You can list the aliases for environment weka381 as follows: wenv.sh alias-list --env weka381","title":"Aliases (list)"},{"location":"examples/#environment-locations","text":"The environments get created in the following directory: Unix (Linux, Mac) $HOME/.local/share/wekavirtualenv Windows %USERPROFILE%\\wekavirtualenv","title":"Environment locations"},{"location":"extend/","text":"Automatic class discovery Thanks to the automatic class discovery (provided by jclasslocator ), you don't have to register anything, you only have to place the command in the same package as the abstract superclass or interface. Command-line It is quite easy to add new commands to the tool: create a class derived from com.github.fracpete.wekavirtualenv.command.AbstractCommand place the class in package com.github.fracpete.wekavirtualenv.command Dataset filenames If your command should handle additional arguments as dataset filenames, then implement the indicator interface com.github.fracpete.wekavirtualenv.command.DatasetHandler . This interface is used by the com.github.fracpete.wekavirtualenv.gui.ArffCommandSelector tool, listing all the tools in the dropdown box that implement this interface. By default, these are by default only the Explorer and ArffViewer . Handling arguments The Delete command just takes a single option, which is the name of the environment to delete. In order for the parsing to work, you have to define a ArgumentParser object in the getParser method and then access the parsed options in the doExecute method, using the Namespace object. Here is the Delete command's code: public class Delete extends AbstractCommand { public String getName() { return \"delete\"; } public String getHelp() { return \"Deletes an existing environment.\"; } public ArgumentParser getParser() { ArgumentParser result = new ArgumentParser(getName()); result.addOption(\"--name\") .dest(\"name\") .help(\"the name of the environment to delete\") .required(true); return result; } protected boolean doExecute(Namespace ns, String[] options) { String msg = Environments.delete(ns.getString(\"name\")); if (msg != null) addError(\"Failed to delete environment '\" + ns.getString(\"name\") + \"':\\n\" + msg); else System.out.println(\"Environment successfully deleted: \" + ns.getString(\"name\")); return (msg == null); } } For more information on the parsing, check out the simple-argparse4j project page. Executing class with main method The AbstractLaunchCommand class makes it easier to execute a class that has a main method. The class for launching the Weka Explorer is quite simple: public class Explorer extends AbstractLaunchCommand implements DatasetHandler { public String getName() { return \"explorer\"; } public String getHelp() { return \"Launches the Weka Explorer.\\n\" + \"You can supply a dataset filename to load immediately in the Explorer.\"; } public boolean supportsAdditionalArguments() { return true; } protected boolean doExecute(Namespace ns, String[] options) { return launch(build(\"weka.gui.explorer.Explorer\", options)); } } In the doExecute method, the build method takes the class name and any options that the class should process. In the Explorer's case an optional dataset to load. Script command If you want to add a script command, you just have to derive it from the com.github.fracpete.wekavirtualenv.command.script.AbstractScriptCommand super class and place it in the com.github.fracpete.wekavirtualenv.command.script package. Here is the code for the DirName command: public class DirName extends AbstractScriptCommand { public String getName() { return \"dir_name\"; } public String getHelp() { return \"Extracts the path from the specified file variable.\"; } public ArgumentParser getParser() { ArgumentParser result = new ArgumentParser(getName()); result.addOption(\"--file\") .dest(\"file\") .help(\"the full path to extract the path from.\") .required(true); result.addOption(\"--dest\") .dest(\"dest\") .help(\"the name of the variable to store the result in.\") .required(true); return result; } protected boolean evalCommand(Namespace ns, String[] options) { File file = new File(ns.getString(\"file\")); getContext().getVariables().set(ns.getString(\"dest\"), file.getParentFile().getAbsolutePath()); return true; } } Filter If you want to add a custom output filter (like grep or tee), then you only have to implement the com.github.fracpete.wekavirtualenv.command.filter.Filter interface (or use the abstract superclass AbstractFilter for convenience) and place it in the com.github.fracpete.wekavirtualenv.command.filter package. Here is the code for the Grep filter: public class Grep extends AbstractFilter { /** the pattern for matching. */ protected Pattern m_RegExp; protected boolean m_Invert; public String getName() { return \"grep\"; } @Override public String getHelp() { return \"For capturing strings that match a regular expression.\"; } public ArgumentParser getParser() { ArgumentParser result = super.getParser(); result.addOption(\"--regexp\") .dest(\"regexp\") .help(\"the regular expression that the output must match to be kept.\") .required(true); result.addOption(\"--invert\") .dest(\"invert\") .help(\"whether to invert the matching sense.\") .argument(false); return result; } public boolean initialize(Namespace ns) { boolean result = super.initialize(ns); if (result) { try { m_RegExp = Pattern.compile(ns.getString(\"regexp\")); } catch (Exception e) { addError(\"Invalid regular expression: \" + ns.getString(\"regexp\"), e); return false; } m_Invert = ns.getBoolean(\"invert\"); } return result; } protected String doIntercept(String line, boolean stdout) { if ((!m_Invert && m_RegExp.matcher(line).matches()) || (m_Invert && !m_RegExp.matcher(line).matches())) { return line; } return null; } } User interface For adding a command in the user interface, you have to subclass the abstract class com.github.fracpete.wekavirtualenv.gui.command.AbstractGUICommand and place the class in the com.github.fracpete.wekavirtualenv.gui.command package. If you want to capture the output of the process, then let the method generatesOutput() return true . If you the command is to be run in the context of a Weka environment, then the method requiresEnvironment() needs to return true . Methods that return true automatically show up in the drop-down list of an environment. Ones that return false , show up in the main menu. The destroy() method is used for stopping any process that got launched. Here is the code for launching the Weka Explorer, which requires an environment and also captures the output of the launched process: public class Explorer extends AbstractGUICommand { protected com.github.fracpete.wekavirtualenv.command.Explorer m_Command; public String getName() { return \"Explorer\"; } public String getGroup() { return \"gui\"; } public boolean requiresEnvironment() { return true; } public boolean generatesOutput() { return true; } @Override protected String doExecute() { String result = null; m_Command = new com.github.fracpete.wekavirtualenv.command.Explorer(); m_Command.setEnv(m_Environment); transferOutputListeners(m_Command); if (!m_Command.execute(new String[0])) { if (m_Command.hasErrors()) result = m_Command.getErrors(); else result = \"Failed to launch Explorer!\"; } m_Command = null; return result; } public void destroy() { if (m_Command != null) m_Command.destroy(); } }","title":"Extend"},{"location":"extend/#automatic-class-discovery","text":"Thanks to the automatic class discovery (provided by jclasslocator ), you don't have to register anything, you only have to place the command in the same package as the abstract superclass or interface.","title":"Automatic class discovery"},{"location":"extend/#command-line","text":"It is quite easy to add new commands to the tool: create a class derived from com.github.fracpete.wekavirtualenv.command.AbstractCommand place the class in package com.github.fracpete.wekavirtualenv.command","title":"Command-line"},{"location":"extend/#dataset-filenames","text":"If your command should handle additional arguments as dataset filenames, then implement the indicator interface com.github.fracpete.wekavirtualenv.command.DatasetHandler . This interface is used by the com.github.fracpete.wekavirtualenv.gui.ArffCommandSelector tool, listing all the tools in the dropdown box that implement this interface. By default, these are by default only the Explorer and ArffViewer .","title":"Dataset filenames"},{"location":"extend/#handling-arguments","text":"The Delete command just takes a single option, which is the name of the environment to delete. In order for the parsing to work, you have to define a ArgumentParser object in the getParser method and then access the parsed options in the doExecute method, using the Namespace object. Here is the Delete command's code: public class Delete extends AbstractCommand { public String getName() { return \"delete\"; } public String getHelp() { return \"Deletes an existing environment.\"; } public ArgumentParser getParser() { ArgumentParser result = new ArgumentParser(getName()); result.addOption(\"--name\") .dest(\"name\") .help(\"the name of the environment to delete\") .required(true); return result; } protected boolean doExecute(Namespace ns, String[] options) { String msg = Environments.delete(ns.getString(\"name\")); if (msg != null) addError(\"Failed to delete environment '\" + ns.getString(\"name\") + \"':\\n\" + msg); else System.out.println(\"Environment successfully deleted: \" + ns.getString(\"name\")); return (msg == null); } } For more information on the parsing, check out the simple-argparse4j project page.","title":"Handling arguments"},{"location":"extend/#executing-class-with-main-method","text":"The AbstractLaunchCommand class makes it easier to execute a class that has a main method. The class for launching the Weka Explorer is quite simple: public class Explorer extends AbstractLaunchCommand implements DatasetHandler { public String getName() { return \"explorer\"; } public String getHelp() { return \"Launches the Weka Explorer.\\n\" + \"You can supply a dataset filename to load immediately in the Explorer.\"; } public boolean supportsAdditionalArguments() { return true; } protected boolean doExecute(Namespace ns, String[] options) { return launch(build(\"weka.gui.explorer.Explorer\", options)); } } In the doExecute method, the build method takes the class name and any options that the class should process. In the Explorer's case an optional dataset to load.","title":"Executing class with main method"},{"location":"extend/#script-command","text":"If you want to add a script command, you just have to derive it from the com.github.fracpete.wekavirtualenv.command.script.AbstractScriptCommand super class and place it in the com.github.fracpete.wekavirtualenv.command.script package. Here is the code for the DirName command: public class DirName extends AbstractScriptCommand { public String getName() { return \"dir_name\"; } public String getHelp() { return \"Extracts the path from the specified file variable.\"; } public ArgumentParser getParser() { ArgumentParser result = new ArgumentParser(getName()); result.addOption(\"--file\") .dest(\"file\") .help(\"the full path to extract the path from.\") .required(true); result.addOption(\"--dest\") .dest(\"dest\") .help(\"the name of the variable to store the result in.\") .required(true); return result; } protected boolean evalCommand(Namespace ns, String[] options) { File file = new File(ns.getString(\"file\")); getContext().getVariables().set(ns.getString(\"dest\"), file.getParentFile().getAbsolutePath()); return true; } }","title":"Script command"},{"location":"extend/#filter","text":"If you want to add a custom output filter (like grep or tee), then you only have to implement the com.github.fracpete.wekavirtualenv.command.filter.Filter interface (or use the abstract superclass AbstractFilter for convenience) and place it in the com.github.fracpete.wekavirtualenv.command.filter package. Here is the code for the Grep filter: public class Grep extends AbstractFilter { /** the pattern for matching. */ protected Pattern m_RegExp; protected boolean m_Invert; public String getName() { return \"grep\"; } @Override public String getHelp() { return \"For capturing strings that match a regular expression.\"; } public ArgumentParser getParser() { ArgumentParser result = super.getParser(); result.addOption(\"--regexp\") .dest(\"regexp\") .help(\"the regular expression that the output must match to be kept.\") .required(true); result.addOption(\"--invert\") .dest(\"invert\") .help(\"whether to invert the matching sense.\") .argument(false); return result; } public boolean initialize(Namespace ns) { boolean result = super.initialize(ns); if (result) { try { m_RegExp = Pattern.compile(ns.getString(\"regexp\")); } catch (Exception e) { addError(\"Invalid regular expression: \" + ns.getString(\"regexp\"), e); return false; } m_Invert = ns.getBoolean(\"invert\"); } return result; } protected String doIntercept(String line, boolean stdout) { if ((!m_Invert && m_RegExp.matcher(line).matches()) || (m_Invert && !m_RegExp.matcher(line).matches())) { return line; } return null; } }","title":"Filter"},{"location":"extend/#user-interface","text":"For adding a command in the user interface, you have to subclass the abstract class com.github.fracpete.wekavirtualenv.gui.command.AbstractGUICommand and place the class in the com.github.fracpete.wekavirtualenv.gui.command package. If you want to capture the output of the process, then let the method generatesOutput() return true . If you the command is to be run in the context of a Weka environment, then the method requiresEnvironment() needs to return true . Methods that return true automatically show up in the drop-down list of an environment. Ones that return false , show up in the main menu. The destroy() method is used for stopping any process that got launched. Here is the code for launching the Weka Explorer, which requires an environment and also captures the output of the launched process: public class Explorer extends AbstractGUICommand { protected com.github.fracpete.wekavirtualenv.command.Explorer m_Command; public String getName() { return \"Explorer\"; } public String getGroup() { return \"gui\"; } public boolean requiresEnvironment() { return true; } public boolean generatesOutput() { return true; } @Override protected String doExecute() { String result = null; m_Command = new com.github.fracpete.wekavirtualenv.command.Explorer(); m_Command.setEnv(m_Environment); transferOutputListeners(m_Command); if (!m_Command.execute(new String[0])) { if (m_Command.hasErrors()) result = m_Command.getErrors(); else result = \"Failed to launch Explorer!\"; } m_Command = null; return result; } public void destroy() { if (m_Command != null) m_Command.destroy(); } }","title":"User interface"},{"location":"maven/","text":"Add the following dependency to your pom.xml : <dependency> <groupId>com.github.fracpete</groupId> <artifactId>weka-virtualenv</artifactId> <version>0.0.30</version> </dependency>","title":"Maven"},{"location":"releases/","text":"The following releases are available: 0.0.30: zip , deb , rpm 0.0.29: zip , deb , rpm 0.0.28: zip , deb , rpm 0.0.27: zip , deb , rpm 0.0.26: zip , deb , rpm 0.0.25: zip , deb , rpm 0.0.24: zip , deb , rpm 0.0.23 0.0.22 0.0.21 0.0.20 0.0.19 0.0.18 0.0.17 0.0.16 0.0.15 0.0.14 0.0.13 0.0.12 0.0.11 0.0.10 0.0.9 0.0.8 0.0.7 0.0.4 0.0.3 0.0.2 Notes: zip - cross-platform (Linux/Mac/Windows) deb - installer for Debian-based systems (eg Ubuntu) rpm - installer for Redhat-based systems (eg RHEL or Fedora) Changes 0.0.28 added support for specifying JVM parameters environment variables can be cleared now 0.0.27 updated list of available downloads to include Weka 3.8.4 and 3.9.4 added comment field in the environments added search box below the environments (GUI only), that allows searching in all fields for the entered substring (case-insensitive) the create , update and delete commands now have a --quiet flag that suppresses output when commands succeed reloading the environments in the GUI no longer leads to flickering 0.0.26 the Clone action in the GUI now supports setup-only option as well (skips wekafiles dir, no props/no packages) 0.0.25 switched from inetutils4j to requests4j 0.0.24 compact state is now kept when reloading environments 0.0.23 added ability to toggle between compact and full view of environments position/size of window and compact view state are now being stored/restored 0.0.22 added list_pkgs command, which simplifies listing installed/available/all packages added Installed packages to user interface, to quickly list installed packages for an environment using inetutils4j library now 0.0.21 added ability to inject custom jars via CLASSPATH environment variable (specified in envvars of environment) command-line to launch command is now being output (useful for debugging) some minor GUI fixes 0.0.20 fixed redirect handling of Weka downloads added Create button to GUI if no environment yet present proxy settings and download of Weka versions now work even if no environment has been created all commands in GUI now refresh the environments panel 0.0.19 fixed unsetting of proxies in the user interface 0.0.18 added proxy support Weka versions can be installed through the user interface now 0.0.17 added install command for downloading and installing Weka zip files from sourceforge.net 0.0.16 added support for scripting via the Script command and in the GUI some scripting commands: variable support (string or string array), set and unset for -loop for iterating over a block of instructions foreach for iterating over a string array variable simple piping of output (stdout or stderr) through filters ( grep , replace , tee ) read_lines for reading text file into string array variable search for files ( list_files ) and directories ( list_dirs ) deleting of files ( del_file ) and directories ( del_dir ) calc for calculating mathematical expressions","title":"Releases"},{"location":"releases/#changes","text":"0.0.28 added support for specifying JVM parameters environment variables can be cleared now 0.0.27 updated list of available downloads to include Weka 3.8.4 and 3.9.4 added comment field in the environments added search box below the environments (GUI only), that allows searching in all fields for the entered substring (case-insensitive) the create , update and delete commands now have a --quiet flag that suppresses output when commands succeed reloading the environments in the GUI no longer leads to flickering 0.0.26 the Clone action in the GUI now supports setup-only option as well (skips wekafiles dir, no props/no packages) 0.0.25 switched from inetutils4j to requests4j 0.0.24 compact state is now kept when reloading environments 0.0.23 added ability to toggle between compact and full view of environments position/size of window and compact view state are now being stored/restored 0.0.22 added list_pkgs command, which simplifies listing installed/available/all packages added Installed packages to user interface, to quickly list installed packages for an environment using inetutils4j library now 0.0.21 added ability to inject custom jars via CLASSPATH environment variable (specified in envvars of environment) command-line to launch command is now being output (useful for debugging) some minor GUI fixes 0.0.20 fixed redirect handling of Weka downloads added Create button to GUI if no environment yet present proxy settings and download of Weka versions now work even if no environment has been created all commands in GUI now refresh the environments panel 0.0.19 fixed unsetting of proxies in the user interface 0.0.18 added proxy support Weka versions can be installed through the user interface now 0.0.17 added install command for downloading and installing Weka zip files from sourceforge.net 0.0.16 added support for scripting via the Script command and in the GUI some scripting commands: variable support (string or string array), set and unset for -loop for iterating over a block of instructions foreach for iterating over a string array variable simple piping of output (stdout or stderr) through filters ( grep , replace , tee ) read_lines for reading text file into string array variable search for files ( list_files ) and directories ( list_dirs ) deleting of files ( del_file ) and directories ( del_dir ) calc for calculating mathematical expressions","title":"Changes"},{"location":"scripting/","text":"With the script command, you can execute simple scripts stored in text files, enhancing the existing command-line commands with special script commands and output filters. Script commands allow you to search for files or directories, store and remove variables, iterate variable arrays, etc. Output filters are used to filter the output of commands, e.g., restrict the information output or redirect it to a file. Script variables are of the format ${name} , with name being the name of the variable. Environment variables are of the format @{name} . Variables get automatically replaced in commands before these get executed. The following script iterates through all ARFF files in directory /home/fracpete/development/datasets/uci/nominal and cross-validates J48 on it. From the output generated by J48, only the lines containing Time taken , Correctly Classified and Root mean squared are filtered out, using the grep filter. This output is then also stored in the file /home/fracpete/j48.txt , using the tee filter. In order to make scripts more readable, especially when performing filtering, long lines can be broken down into multiple ones by ending them all but the last one with a backslash ( \\ ). Empty lines are skipped, as well as comment lines starting with # . # setup set searchdir=/home/fracpete/development/datasets/uci/nominal set outfile=/home/fracpete/j48.txt set env=weka392 # search for arff files echo --message \"\\nsearch dir: ${searchdir}\" list_files --dir ${searchdir} --regexp \".*\\.arff\" --dest files # evaluate J48 on each of the arff files and output accuracy in text file foreach --iterate files --dest file echo --message \"\\n--> ${file}\" | tee --stdout --append --output ${outfile} run ${env} --class weka.classifiers.trees.J48 -t ${file} \\ | grep --stdout --regexp \".*(Time taken|Correctly Classified|Root mean squared).*\" \\ | tee --stdout --append --output ${outfile} Help If you want to get more help on filters, use the following commands: filter_help -- outputs a list of all available filters filter_help --filter <name> -- outputs a detailed help screen for the named filter If you want to get more help on script commands, use the following commands: script_help -- outputs a list of all available script commands script_help --cmd <name> -- outputs a detailed help screen for the named script command Script commands The following script commands are available: Available script commands: base_name <options> Extracts the file name without the path from the specified variable. calc <options> Calculates the result of a mathematical expression. del_dir <options> Deletes the specified directory (recursively). del_file <options> Deletes the specified file. dir_name <options> Extracts the path from the specified file variable. dump_vars Just outputs all the currently set variables. flatten <options> Flattens an array variable into a single string variable. for <options> Iterates through the numeric values from lower to upper bound, using the specified step amount. foreach <options> Iterates through the elements of a variable and executes the nested instructions. list_dirs <options> Locates directories in specified directory and stores them in a variable. Search can be recursive, directory names (excl parent path) can be matched again regular expression. list_files <options> Locates files in specified directory and stores them in a variable. Search can be recursive, file names (excl path) can be matched again regular expression. read_lines <options> Reads all the lines in a text file into a variable. Can skip empty lines and lines that match regular expression. replace <options> Performs string replacement, simple or regular expression based. If no replacement string is provided the empty string is used. replace_ext <options> Replaces the extension of the file stored in the variable with the supplied one. set <args> Sets a variable in the form of 'name=value'. The value can contain other variables, which will get evaluated in a lazy fashion. split <options> Splits a string variable into a string array variable. unset <args> Removes the specified variable. Notes: <options> the command supports additional options, specify the script's name to output detailed help. <args> the command supports additional arguments see script's help. Output filters The following output filters are available: Available filters: grep <options> For capturing strings that match a regular expression. replace <options> Performs string replacement, simple or regular expression based. tee <options> Tees off the output to a file. Notes: <options> the filter supports additional options, specify the filter's name to output detailed help.","title":"Scripting"},{"location":"scripting/#help","text":"If you want to get more help on filters, use the following commands: filter_help -- outputs a list of all available filters filter_help --filter <name> -- outputs a detailed help screen for the named filter If you want to get more help on script commands, use the following commands: script_help -- outputs a list of all available script commands script_help --cmd <name> -- outputs a detailed help screen for the named script command","title":"Help"},{"location":"scripting/#script-commands","text":"The following script commands are available: Available script commands: base_name <options> Extracts the file name without the path from the specified variable. calc <options> Calculates the result of a mathematical expression. del_dir <options> Deletes the specified directory (recursively). del_file <options> Deletes the specified file. dir_name <options> Extracts the path from the specified file variable. dump_vars Just outputs all the currently set variables. flatten <options> Flattens an array variable into a single string variable. for <options> Iterates through the numeric values from lower to upper bound, using the specified step amount. foreach <options> Iterates through the elements of a variable and executes the nested instructions. list_dirs <options> Locates directories in specified directory and stores them in a variable. Search can be recursive, directory names (excl parent path) can be matched again regular expression. list_files <options> Locates files in specified directory and stores them in a variable. Search can be recursive, file names (excl path) can be matched again regular expression. read_lines <options> Reads all the lines in a text file into a variable. Can skip empty lines and lines that match regular expression. replace <options> Performs string replacement, simple or regular expression based. If no replacement string is provided the empty string is used. replace_ext <options> Replaces the extension of the file stored in the variable with the supplied one. set <args> Sets a variable in the form of 'name=value'. The value can contain other variables, which will get evaluated in a lazy fashion. split <options> Splits a string variable into a string array variable. unset <args> Removes the specified variable. Notes: <options> the command supports additional options, specify the script's name to output detailed help. <args> the command supports additional arguments see script's help.","title":"Script commands"},{"location":"scripting/#output-filters","text":"The following output filters are available: Available filters: grep <options> For capturing strings that match a regular expression. replace <options> Performs string replacement, simple or regular expression based. tee <options> Tees off the output to a file. Notes: <options> the filter supports additional options, specify the filter's name to output detailed help.","title":"Output filters"}]}